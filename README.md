
Git의 사용목적 : 
1. 여러명이 공유한 파일을 동시에 편집하여, 충돌이 나지 않도록 하기 위해서
2. 어느파일이 최신인지, 어떤부분이 변경된지를 파악하기 위해서

Git(분산형 버전관리 시스템)의 이점
1. 소스코드가 변경된 이력을 쉽게 확인 할 수 있다.
2. 특정 시점에 저장된 버전과 비교하거나, 특정시점으로 되돌아 갈 수있다.


원격저장소와 로컬저장소
원격 저장소 : 파일이 원격저장소 전용 서버에서 관리되며, 여러사람이 함께 공유하기 위한 저장소
로컬 저장소 : 내 PC에 파일이 저장되는 개인전용 저장소


커밋 : 파일 및 폴더의 추가/변경사항을 저장소에 기록 -> 이전상태부터 현재상태까지의 변경이력이 기록됨


작업트리 --------------- 인덱스 ------------------------저장소

커밋은 작업트리에 있는 변경내용을 저장소에 바로 기록하는 것이 아니라, 그사이의 공간인 인덱스에 파일 상태를 기록(stage)
	-> 내가 원하는 일부변경사항만 , 인덱스에 등록해 커밋할 수 있다.


push
-> 내 PC의 로컬 저장소에서 변경된 이력을 원격저장소에 공유하려면, 로컬저장소의 변경 이력을 원격저장소에 업로드해야 합니다.
-> 원격저장소에 내 변경이려기 업로드 되어, 원격저장소와 로컬저장소가 동일한 상태가 된다.



clone
누군가의 변경이력이 적용된 원격저장소가 있다면, 그걸 웹에서 통째로 복제해와 내 PC에서 작업할 수 있다.


Pull
원격저장소를 공유해 여러사람이 함께 작업을 하면, 모두가 같은 원격저장소에 Push합니다.
원격저장소에서 로컬저장소로 업데이트를 하는 것을 풀(Pull)을 실행합니다.


backlog.com


변경되는 이력의 주의할 점
내가 pull을 실행한 후 다른 사람이 push를 하여 원격저장소를 업데이트 해버렸을 때, 나의 push요청이 거부되어 버린다.
-> 이런경우 Merge(병합) 이라는 작업을 진행해서, 다른 사람의 업데이트 이력을 내저장소에도 갱신해야 한다.
-> 만약 병합하지 않은채로 이력을 덮어스게 되면, 다른 사람이 push한 업데이트내역이 사라져 버린다.


브랜치
여러개발자들이 동시에 다양한 작업을 할 수 있게 만들어주는 기능
각자 독립적인 작업 영역(저장소) 안에서 마음대로 소스코드를 변경할 수 있음
이렇게 분리된 작업영역에서 변경된 내용은 나중에 원래의 버전과 비교해서 하나의 새로운 버전으로 만들어 낼 수 있다.

-> 메인브랜치에서 자신의 작업 전용브랜치를 만든다음, 각자 작업을 진행한 후 , 작업이 끝난사람은 메인브랜치에 자신의 브랜치의
   변경사항을 적용합니다. (다른사람의 작업에 영향을 받지 않고, 독립적으로 특정작업을 수행하고 그결과를 하나로 모아나감)




master 브랜치
새로운저장소에 새로운 파일을 추가한다거나 추가한 파일의 내용을 변경하여 그내용을 저장


통합브랜치(master브랜치를 주로 통합브랜치로 쓴다.)
언제든지 배포할 수 있는 버전을 만들 수 있어야 하는 브랜치 -> 모든기능이 정상적으로 정상적으로 동작하는 상태


토픽브랜치 
기능추가나, 버그수정과 같은 단위 작업을 위한 브랜치 , 우리가 사용했던 브랜치들이 토픽브랜치


브랜치를 전환하기
처음에 Git을 설치하게 되면, master브랜치가 선택되어있고, 현재 선택된 브랜치가 아닌 다른 브랜치에서 작업하고 싶을때
체크아웃 명령어를 실행하여 원하는 브랜치로 전환할 수 있습니다.

체크아웃을 실행하면, 우선 브랜치 안에 있는 마지막 커밋내용이 작업트리에 펼쳐지게 됩니다. 
브랜치가 전환되었으므로, 이후 실행한 커밋은 전환한 브랜치에 추가됩니다.


HEAD
현재 사용중인 브랜치의 선두부분을 나타내는 이름입니다. 기본적으로 master의 선두부분을 나타냅니다.
HEAD를 이동하면, 사용하는 브랜치가 변경됩니다.

HEAD~1 		1세대앞의 커밋
HEAD~1^1 	1세대앞의 커밋이며, 첫번째원본


stash
파일의 변경내용을 일시적으로 기록해두는 영역.
stash를 사용하여, 작업트리와 인덱스내에서 아직 커밋하지 않은 변경을 일시적으로 저장해둘 수 있습니다.
stash에 저장된 변경내용은 나중에 다시 불러와 원래의 브랜치나 다른 브랜치에 커밋할 수 있습니다.




브랜치 통합 : merge, rebase가 있다 -> 어느쪽을 사용하느냐에 따라 통합후 브랜치이력이 달라진다.


merger
fast-forward 병합 : master가 분기한 브랜치가 있을때, 분기한 브랜치로 master브랜치가 이동하여 분기브랜치의 내용을 적용할 수 있다.
non -fast-forward 병합 : master브랜치가 분기한 브랜치가 있고, 그이후 master브랜치가 변경내용이 있을때, 분기한 브랜치의 내용과
			하나로 통합할 필요가 있다.

rebase
non-fast-forward 에서  분기된 브랜치를 master브랜치 뒤로 이력을 이동하게 한다음, 이력이 하나의 줄기로 이어지면, 
master는 rebase하여, 분기된 브랜치로 병합하면 된다.



팀마다 다른 운용
토픽 브랜치에 통합 브랜치의 최신 코드를 적용할 경우에는 rebase 를 사용,
통합 브랜치에 토픽 브랜치를 불러올 경우에는 우선 rebase 를 한 후 merge





-  --amend 옵션을 지정하여 커밋을 수행하면 같은 브랜치 상에서 이전에 커밋했던 내용에 새로운 내용을 추가하거나 설명을 수정
- revert 명령어를 이용하면, 특정 커밋의 내용을 삭제 할 수 있다.
- reset 명령어를 이용하면, 더이상 필요없어진 커밋들을 버릴 수 있다 명령어 실행시 어떤모드로 실행할 지 지정하여 HEAD 위치와 인덱스 , 작업트리 내용을 함께 되돌릴지 여부를 선택
	-커밋만 되돌리고 싶을때 (soft), 변경한 인덱스의 상태를 원래대로 되돌리고 싶을때 (mixed) , 최근의 커밋을 완전히 버리고 이전의 상태로 되돌리고 싶을 때(hard)


다른브랜치로 부터 특정커밋을 가져와서 내브랜치에 넣기
cherry-pick을 이용하면 다른 브랜치에서 지정한 커밋을 복사해서 현재 브랜치로 가져올 수 있다.




NodeJS, ORM, Sequelize, MVC, MariaDB, Git, Bitbucket, ER Diagram,
Angular JS, Express, Bootstrap, RESTful API, JSON, Responsive Web


nodejs 공부(서버사이드 언어 : 스크리트 언어 중에서 서버사이드에서 실행되는 스크립트 언어)

node.js는 구글이 개발하여 현재 크롬브라우저에 탑재되어 있는 Javascript 엔진인 V8을 기반으로 만들어진 Serverside Javascript이다.


V8 자바스크립트 엔진
-> 구글이 크롬 웹브라우저를 개발하면서 함께 개발한것이 V8 자바스크립트 엔진이다.
V8은 자바스크립트 처리 속도가 기존에 웹브라우저에 포함된 엔진들보다 월등히 빨랐다
자바스크립트의 엔진들은 바이트코드를 변환하거나, 인터프리터하여 처리하였지만, V8은 JIT 컴파일 방싣을 사용하여
성능을 획기적으로 개선했습니다.


JIT 컴파일 방식
-> 자바스크립트를 인터프리트 하지 않고 실행 즉시 기계어로 컴파일한다.


Node의 특징인 Single Thread 기반

기존의 WAS들이 Thread 기반이기에 동시에 수많은 사용자의 Request가 들어오고 시간이 오래걸리는 File, Network I/O 가 해당로직에
존재하는 경우 기존의 Thread 기반의 WAS에서는 속도가 느려질 수 밖에 없었다. 왜냐면, File, Network등의 작업이 끝나 Response를 던져 줄때가지
Thread pool을 점유하고 있기 때문에 뒤늦게 Request를 날린 사용자가 Response를 주고 해당 Thread pool에 대한 점유를 끝낼때가지 대기햐야 한다.


ㅡ> 그러나 Node의 등장으로 인해서
Event call back 을 이용한 Node는 기존의 WAS와는 다르게 시간이 오래걸리느 File, Network I/O에 대해 Non-block 되도록 비동기로 처리하고
오랜 그들의 작업이 끝내면 작업이 완료되었다는 신호를 받아 처리한다.
그러다 보니 기존이 Thread 기반의 WAS에 비해 동시 Request를 더 많이  받을 수 있다는 장점이 있다.


Node의 특징

1. Chrome JavaScript Engine V8 기반의 서버 플랫폼 -> Javascript를 compile 하여 native machine code 변경후 runtime 시 다시 최적화

2. 빠르고 확장이가능한 Network 프로그램 개발에 특화( TCP, UDP 관련 프로그램 개발 가능)

3. Single Thread 기반의 Non-Blocking I/O model 사용(비동기적 방식)

4. Event Driven Programming Model





Node의 장 단점

장점 :  Single Thread 기반의 Event Callback 방식 처리로 인해 대용량의  Request를 받아들일 수 있다.
	socket.io 모듈을 이용한 소켓프로그래밍이 매우 쉽다.


단점 :  CPU intensive 한 영역에서는 약하다.
	해당 코드가 수행되어야 코드에서 에러가 나는지를 확인할 수 있고, 에러가 날 경우 프로세스 자체가 내려가기 때문에 주의해야한다



ORM
-> 설계된 데이터베이스와 객체와의  관계에 대한 설정등을 포함하여 보다 객체지향적인 시스템의 완성을 위한 도구



Node js의 ORM - Sequelize, Bookshelf.js, node-orm2
Sequelize.js는 Node.js 기반의 ORM이다. 

Sequelize ORM : 객체와 모델을 매핑
프로그래밍 언어로 직접 데이터베이스에 말할 수 없기 때문에 중간에 통역인 ORM 데이터 베이스가 알아들을 수 있는 언어로 번역하여 전달하는 것이다.





<Maria DB>
Maria DB - 오픈소스의 관계형 데이터베이스 관리시스템(RDBMS)
MySQL과 동일한 소스코드를 기반으로 하며, GPL, v2라이센스를 따른다.

MySql과 호환성
1. 데이터와 테이블 정의 파일(.fmt) 파일이 바이너리 호환이 된다.
2. 모든 파일이름과 바이너리, 경로, 포트 , 소켓 그리고 기타 등등이 동일하다
3. 모든 MySQL 커넥터가 마리아 DB와 동일하게 작동한다.


성능 - 마리아 DB는 MySQL과 비교해 애플리케이션 부분 속도가 약 4~5천배정도 빠르며, MySQL이 가지고 있는 모든제품의 기능을 완벽히 구현
기능 - 쓰레드 풀 기능이 내장됐으며, 스토리지 엔진을 활용한 샤딩기술을 제공한다.

mysql과 비교했을 때, 장점

1. 월등히 빠른 쿼리 타임을 들수 있다.

2. 다양한 추가 기능들이 있다.
	- Microseconds in MariaDB  : 테이블을 생성할 때 시간관련 자료형에 정밀도를 설정할 수 있다.
	  정밀도는 0부터 6 까지 설정할 수 있으며, 설정된 값만큼의 microseconds


3. 다양한 Storage Engine을 지원한다.






Bitbucket : 분산버전 관리 툴인 Git을 사용하는 프로젝트를 지원하는 웹호스팅 서비스 입니다
            Github와 달리 private(비공개) 저장소도 무료로 사용할 수 있습니다.




ER Diagram
데이터 모델링 분야 (개체 - 관계 모델) : 구조화된 데이터에 대한 일련의 표현
					개체 타입과 이들간의 관계타입을 이용해 현실 세계를 개념적으로 표현한것.

Entity - 그냥 직사각형
Weak entity - 직사각형 두개
Relationship - 마름모
Attribute - 타원형
Multi-valued attribute 점있는 타원형


개체(엔티티) : 분리된 물체 하나를 표현한다 , 명사에 해당된다
관계(릴레이션 쉽) : 두 개 이상의 엔티티들이 어떻게 서로 연관되어 있는지


Angular Js - 구글에서 만든 자바스크립트 프레임워크

Angular JS의 특징
1. 자바스크립트로 작성할 코드량을 줄여준다.
	- Dom을 선택하고 조작하는 자바스크립트 코드를 작성하지 않아도 된다.

2. 양방향 데이터 바인딩이 가능하다.
	- 모델의 데이터와 뷰 데이터가 양방향 데이터 바인딩이 되어, 모델이 바뀌면 뷰데이터도 같이 변경된다.

3. HTML, CSS 로직 등 개발 영역을 명확하게 분리해준다.
	- 기존 자바스크립트에서는 Dom 조작과 이벤트 처리를 위해 HTML을 잘 알고 있어야 했으나, AngularJS는 뷰코드와 로직 코드가 명확하게 분리된다.


주요개념

Model (모델) 	- 단순 자바스크립트 객체로 된 데이터
		- 보통  JSON으로 표현되는 애플리케이션의 특정한 데이터 구조를 말한다.
		- json 데이터를 jQuery의 $.ajax메서드를 래핑한 Angular의 $http 를 통해 XHR로 서버에서 가져오거나 페이지를 로딩 할때, 코드에서
		  직접 (데이터베이스에서) 읽어오도록 할 수 있다.

View(뷰)	- 템플릿과 모델이 합쳐져서 보여지는 화면 (DOM구조로 되어 있음)
		- MVC 프레임워크를 사용한다면 뷰를 갱신할 모델 데이터를 내려 받은 뒤 Html에서 해당 데이터를 보여줄 것이다.

Controller	-자바스크립트로 된 로직 영역
		- 컨트롤러는 서버에서 직접 뷰로 접근하는 일종의 중간 통로로서 필요할 때마다 서버와 클라이언트 통신으로 데이터를 변경한다.

Scope(스코프)	- 뷰와 컨트롤러 사이에서 데이터를 연결해주는 역활
		- 모델과 뷰를 감시하고, 컨트롤러에 이벤트를 보내는 역활


Directive(디렉티브) - html을 확장하는 AngularJS의 지시어
		    - ex) ng-app, ng-controller, ng-click 등


Data Binding(데이터 바인딩) - 모델과 뷰의 데이터를 실시간으로 연동

Moduel(모듈) - 모든 자바스크립트 기능들이 ng-app="모듈명"을 시작으로 모듈 단위로 관리
	     - 컨트롤러, 서비스, 필터 등을 포함하며, 응용프로그램의 서로 다른 기능을 구성하는 컨테이너


Service(서비스) - 특정 기능을 담당하는 객체
		- 싱글톤 객체로 인스턴스가 하나만 존재한다.




Express는 자바스크립트 기반으로 node.js 실행환경에서 호스트된 웹 프레임 워크이다. 





Bootstrap - 트위터에서 시작된 HTML5 기반의 오픈소스 웹 디자인 프레임워크로 각종 레이아웃, 버튼, 입력창 등의
	    디자인을 css와 Javascript 로 만들어 놓은 것이다.


장점 -  1. 글자, 인용문, 목록, 표, 입력폼, 버튼, 이미지, 아이콘, 드롭다운 메뉴, 버튼, 탭, 리스트, 메뉴바 등등
       웹페이지에서 많이 쓰이는 요소를 거이 내장하고 있다
      
	2. 웹브라우저에 크기에 따라 자동으로 정렬되는 그리드 시스템을 채용하고 있다.  -> 반응형 웹 디자인을 지원한다.


단점 -  1. 디자인이 정형화 되어 있기 때문에 비슷한 디자인의 페이지가 양산될 수 있다는 것
	2. HTML 5를 인식시키는 JavaScript 코드가 필요하고 , 3.0에서부터는 IE8 부터 지원한다.



	
RESTful API 
-> 현재의 아키텍처가 웹의 본래 설계의 우수성을 많이 사용하지 못하고 있다고 판단한 대서 나오게됨


REST의 기본요소 : 리소스, 메서드, 메세지 3가지 요소로 구성된다.
ex) 이름이 Terry 인 사용자를 생성한다 라는 호출

"사용자"는 리소스, "생성한다" 라는 행위는 메서드 그리고 이름이 "Terry"인 사용자는 메세지가 된다.


HTTP POST, http://myweb/users(리소스)
{
	"users":{
	   "name":"terry"
	}
}

와 같은 형태로 표현되며, 생성한다의 의미를 갖는 메서드는 HTTP Post 메서드가 되고, 생성하고자 하는 대상이 되는 사용자


HTTP 메서드
REST에서 행위에 대한 메서드를 HTTP 메서드를 그대로 사용한다.
여러가지 메서드가 있지만, REST에서는 CRUD에 대한 4가지의 메서드만을 사용한다.

Idempotent(Yes/No)
Post(Create) No , Put(Update) Yes, Get(Select) Yes, Delete(Delete) Yes
Idempotent는 여러번 수행해도 결과가 같은 경우를 의미한다.

Post의 경우에는 리소스를 계속 생성하는 경우이기 때문에 Idempotent하지 않다
Get의 경우에는 게시물의 조회수를 카운트 해주는 기능은 Idempotent하지 않은 메서드로 정의해야한다.


REST의 리소스
REST는 리소스 지향 아키텍처 스타일이며, 명사로 표현하고, 각 세부 리소르에는 id를 붙인다.
즉, 사용자라는 리소스타입을 http://myweb/users라고 정의했다면, terry 라는 id를 갖는 리소스는
http://myweb/users/terry라는 형태로 정의 할 수 있다.

HTTP Post, http://myweb/users/
{
	"name":"terry"
	"address":"seoul"
}


-> 리소스를 이름은 terry, 주소는 seoul이라는 내용(메세지)로 HTTP post를 이용해서 생성하는 정의


조회 : HTTP GET, http://myweb/users/terry (
수정 : HTTP PUT, http://myweb/users/terry
{
	"name":"terry",
	"address":"suwon"
}

삭제 : HTTP DELETE, http://myweb/users/terry
단순하게 리소스를 정의 해준다음에 id가 terry인 사용자의 정보를 삭제하는 방법이다

REST의 특성

1. 유니폼 인터페이스 : HTTP 표준에만 따른다면, 어떤한 기술도 사용이 가능한 인터페이스
2. 무상태성/ 스테이트리스 : HTTP Session 과 같은 컨텍스트 저장소에서 상태정보를 저장하지 않는 형태, API 서버는 들어오는
			    요청만을 들어오는 메세지로 처리, 세션과 같은 컨텍스트 정보를 신경쓰지 않아도 된다.

3. 캐슁 : HTTP라는 기존의 웹표준을 그대로 사용하기 때문에, 웹에서 사용하는 기존의 인프라를 그대로 활용이 가능하다.

4. 자체표현구조 : API메세지 자체만 보고도 API를 이해할 수 있는 표현구조를 갖는다.

5. 클라이언트 - 서버 구조 : REST서버는 API를 제공하고, 제공된 API를 이용해서 비즈니스 로직 처리 및 저장을 책임진다.
			    클라이언트와 서버의 역활이 명확하게 구분된다.




JSON(JavaScript Object Notation) 

- 속성 - 값 쌍으로 이루어진 데이터 오브젝트 교환 포맷의 일종이다
- XML에 비해 경량화된 데이터 교환포맷으로 기존의 XML을 가볍게 만든것이다.
- Ajax로 서버와 통신하며, 데이터를 주고 받을 때, 데이터 교환을 쉽게 하기 위해 JSON을 사용한다.



기본형태

{
	"age":29,
	"name":"JIWOO"

}

주고 받을 수 있는 자료형은 숫자, 문자열, boolean, 배열, 객체이며, 기본데이터 배열은 key, 와 value로 구성되어있으며, 중괄호로 감싼다

특징
1. 문자열을 사용하므로, 오버헤드가 거의 없다.
2. 프로그래밍 언어에 독립적이므로 대부분 언어에서 사용이 가능하다.
3. 최신브라우저는 대부분 JSON 파서를 내장하므로 사용하기가 편리하다
4. 자바스크립트 문법을 사용해서 eval명령의 사용이 가능하다.


저장되는 형태 3가지

1. 중괄호 ({})로 시작, 끝을 표시
2. 배열 대괄호 안에 콤마로 값, 순서구분 ex) ["오라클자바커뮤니티",2312312,{"이름":"오라클자바커뮤니티"},[821312,"오라클자바커뮤니티"]]
3. 기본자료형 : 숫자, 문자열, 논리형, null, 네가지 타입을 지원, 날짜, 시간, 화폐 등은 지원안함





# Node.js 정리 - KCS 

##1.Node.js 란?

### 구글 크롬의 자바스크립트 엔진으로 만들어진 서버사이드 플랫폼. 
### NON_BLOKCING을 위해 콜백함수 사용 - > 비동기식 

##Node.js 특징 

### 1.비동기 I/O처리, 이벤트위주: 데이터가 반환할떄까지 기다리지않고 다음 API 실행. 
###                               이전 API값 결과반환시. Node.js가 이벤트알림 메커니즘 이용
### 2.빠른속도 : 자바의 V8엔진
### 3.단일 스레드, 확장성 : 쓰레드 1개만 사용. 이벤트메커니즘을 통해 서버가 멈추지않아 확장성 증가
### 4.노버퍼링 : 버퍼링이 없으며 데터를 CHUNK로 출력.


#ORM 이란?
## OOP 언어와 RDBMS의 시스템을 매핑하여 데이터를 다루는 OOP를 쉽개해줌. 

###1. 특정 DBMS에 종속되지 않는다.
###2. SQL문이 코드에 들어가지 않는다.
###3. 중첩 데이터를 바인딩해줌.

##단점
### 퍼포먼스가 느림, 튜닝이어려움


#Sequelize ?
## Node.js 의 ORM으로 Promise기반으로 동작. 

## Promise 란? 
### 비동기 작업방식을 약속하는것.  Pending , fulfilled ,rejectd 상태 존재.

#MVC 패턴 

## Model - View - Controller 역할을 나누어 개발하는 디자인 패턴.
### Model : 객체 데이터, DB쿼리를 통한 데이터
### View : 사용자에게 보여지는 화면 
### Controller : View 와 Model을 연결.

#EXPRESS ? 

##Node.js 의 MVC 모듈이 Express 

### View = ejs 파일
### Controller = 라우터

### Package.json의 dependencies 에 "express" : "*" 추가해줌. pom.xml과 비슷 


#REST API

## 무엇을(HTTP URI 리소스) 어떻게 한다(HTTP method + payload)
## HTTP 메소드와 CRUD 비교 
### POST = create
### GET = read
### PUT = update/replace
### PATCH = update/modify
### DELETE = delete

## 예시) GET www.plus.co.kr/images/main HTTP/1.1 Accept:image/jpg
## HTTP메소드와 URI로 원하는 내용을 모두 표현하는것.
## RESTFUL 한것 = 리소스/HTTP메소드/확장자x/동사 x 명사만 사용한것.

## 특징 
### 1.Uniform 
### 2.stateless
### 3.HTTP cacheable
### 4.self-decriptiveness
### 5.Client - Server 역할 명확히 분리
### 6.확장성 및 보안 향상
### 7.Code on demand - 서버에서 스크립트를 통해 클라이언트부분 수행가능

### 이것이 모두 만족 할 시 RestFul 하다고 함. 

## 단점
### 표준이없음, RDBMS와 어색함(NoSQL과 잘맞음) , HTTP 한계에 묶임.

========================== ypLim ====================================
Node JS
	- 대표 ORM : Sequelize
Express
	- nodeJS를 위한 빠르고 개방적이고 간결한 웹 프레임워크
	- 일반적인 Web Application 기능을 포함하는, 
	  WebApp을 개발하는데 필요한 수많은 모듈을 집합하여 사용자가 쓰기 쉽도록 만들어 둔 모듈
	- 정규식을 지원하는 강력한 라우팅 메커니즘, 심플한 라우트 필터링
	- 미들웨어 아키텍처를 활용하며 다양한 데이터 출력지원
	- 다중으로 템플릿 엔진을 허용하는 간단한 변수전달 뷰 시스템
	** 핵심 ㅡ> 라우터 자체에 미들웨어나 조건들을 끼워넣고 순서대로 순환해가며 처리해가는 것

ORM(Object Relational Mapping)
	- OOP언어와 데이터를 다루는 RDBMS와의 상이한 시스템을 매핑하여, 쉽게 데이터관련 OOP프로그래밍을 하도록 하기 위한 기술이다.
	- 객체지향 애플리케이션은 객체 지향대로 다루고, 관계형 데이터베이스는 
	   관계형 데이터베이스대로 설계하고 사용할 수 있도록 중간에서 도와주는 기술

	- Ex) 		OOP				RDBMS
		        클래스		<ㅡ>		테이블
		     Object-graph      <ㅡ>		Relation
	   로 표현이 가능한데 표현방식에서 상당한 차이점이 있어 매핑을 통해 변환을 해주어야 한다.
	장점 ㅡ> 
		● 개발자가 OOP나 CBD에 의한 개발에만 집중가능
		● RDBMS관련 부분의 고려사항 최소화
	 	● OOP언어/CBD개발 방법론에서 클래스나 컴포넌트 설계 및 개발에서 
		    이질적인 RDBMS 관련된 부분을 최소화하고, 원 제품의 로직 구현에 
 		    충실하고자 하는 의도에서 나온 산물
		● 생산성이 높아지고 캐시 등 다양한 저장소를 활용하기에 유연한 구조를 만들어 준다.
		● 탑다운(Top-down)방식의 설계를 채택할 수 있는 경우 장점이 극대화 된다.
	단점 ㅡ>
		● 현실적으로 자바계층에 맞춰 DB스키마를 설계할 수 없는 프로젝트가 상당히 많으며
	 	    이런 경우 ORM을 염두에 두지 않고 설계된 리거시 스키마를 그대로 두고 바텀업(bottom-up)방식으로 
             구현하는 접근을 할 수 밖에 없기에 ORM의 장점이 상당히 퇴색
	 	● ORM기술 자체도 최적화나 복잡도, 또는 추상화 등의 이유로 꾸준히 비판받아왔다. 
	 	● 현재는 ORM을 사용하지 않고도 영속성 문제를 깔끔하게 처리할 수 있는 
		    대안도 존재한다.
Maria DB
	- mysql 코어를 가지고 분리개발 한 것이 mariaDB
	   Mysql의 모든 명령어, 인터페이스, 라이브러리와 같은 API가 MariaDB에도 존재하며 
	   MariaDB는 사실상 MySQL의 완벽한 대체제라고 말할 수 있다.
	   기능상의 차이는 거의 없지만 MariaDB의 퍼포먼스가 더 좋고 엔진도 추가되어 
	   MySQL보다 뛰어나다.
	장점 ㅡ> 
    	가장 큰 장점은 속도, 2배가량 퍼포먼스가 개선되었다.
MVC (Model View Controller)
	- 디자인 패턴 중 하나 ㅡ> 하나의 애플리케이션(프로젝트)를 세 가지의 역할로 구분한 패턴
	 Model ㅡ> 애플리케이션의 정보 즉 데이터를 담당하며 데이터의 가공을 책임지는 컴포넌트
	 View ㅡ> 데이터 및 객체의 입력, 그리고 보여주는 출력을 담당하는 사용자 인터페이스 요소 
		  클라이언트 측 기술인 HTML/CSS/JavaScript 를 모아둔 컨테이너
	 Controller ㅡ> Model과 View의 다리역할을 하는, 비즈니스 로직을 담당하는 Controller
	● 왜 사용할까? 
	ㅡ> Model, View, Controller 서로 영향을 받지 않는 3가지로 분리하여 
	      각자의 역할에 집중할 수 있게끔 개발가능
	      애플리케이션의 확장성, 유지보수성, 유연성이 증가하고 중복코딩을 줄일 수 있다.
	유연성 ㅡ> 새로운 요구사항에 대해 최소한의 비용으로 보다 유연하게 대처할 수 있는 것
	     단점 - View가 Model을 이용하기에, 서로간의 의존성을 완벽히 피할 수 없다는 단점이 있다
		     ㅡ> 좋은 MVC는 의존성을 최대한 낮게 디자인한 패턴
	** NodeJS용 MVC 프레임워크로 Express(모듈) 가 있다.
AngularJS
	- 2013년 9월 1.0.8버전으로 정식 출시
	- AngularJS는 HTML을 확장시켜 동적인 Application을 지원하며 
	   데이터가 변경함에 있어 자동적으로 AngularJS에서 UI의 요소를 만들고 
	   데이터 필터링/소팅 등 많은 기능을 제공
	- AngularJS의 가장 핵심기능은 양방향 데이터바인딩 기능
	
	장점 
	- JavaScript나 jQuery에 비해 개발자의 부담이 훨씬 줄어든다.
	- 프레임워크 코어에 DOM변환 엔진을 넣어둠으로써 템플릿을 HTML파일로 작성가능
	   DOM변환 엔진을 통해 개발자는 AngularJS의 다양한 디렉티브(지시자)를 이용하여 
	   HTML문법을 확장가능
	● Scope / Model / View / Controller / Directives(지시자)
	** Scope ㅡ> 모델 변경을 감지하고 표현하기 위한 책임을 갖는다. 
				(scope를 통해 View와 Controller간의 소통이 가능)
	** Model ㅡ> 화면 템플릿에 합쳐지는 데이터를 가지고 있는 자바스크립트 객체(= 데이터)
		    	Scope는 항상 모델을 참조하고 있다.
	** View  ㅡ> Angular는 템플릿이 HTML이어서 바로 DOM으로 해석되고 
				 DOM안에 directive가 템플릿 엔진 $compile지시어를 통해 $watch를 설정하고 
				 모델의 변경을 계속 감시하게 된다.
		    	 View는 템플릿으로 Scope의 투영체이고, Scope는 Model과 View를 연결하며
		     	Controller로 이벤트를 보내는 역할을 한다.  
	** Controller ㅡ> scope에 model과 function을 정의해주는 역할 
						ㅡ> 그러면 View가 그것들을 사용
			   			자바스크립트이며 업무적 행위를 정의한다. 
			   			또한 DOM 렌더링 정보가 일체 없다.
	** Directives(지시어) ㅡ> HTML을 확장하여 주고 행위를 일으키는 주체 
				  			Ex) 데이터 바인딩을 위한 중괄호 표기 {{}}
				      		컨트롤러가 뷰의 어느 부분을 감독할지 정하는 ng-controller
				      		input을 해당 모델의 구성물에 바인딩하는 ng-model
				      		이들 모두 directive를 이용한 확장 문법이다.

Git (ahahah)
	- Repository(저장소) ㅡ> 파일이나 폴더를 저장해 두는 곳
							Git저장소의 장점은 파일이 변경이력별로 구분되어 저장된다.
	- 커밋 ㅡ> 파일 및 폴더의 추가 및 변경 사항을 저장소에 기록하기 위함
	- 커밋메세지형식 ㅡ> 명료하고 이해하기 쉽게 남기기
						1번째 줄 : 커밋 내의 변경 내용을 요약
						2번째 줄 : 빈칸
						3번째 줄 : 변경한 이유
	- 브랜치 ㅡ> 여러 개발자들이 동시에 다양한 작업을 할 수 있게 만들어 주는 기능
		   		독립적으로 어떠한 작업을 진행하기 위한 개념
	- 통합 브랜치 ㅡ> 언제든지 배포할 수 있는 버전을 만들 수 있어야 하는 브랜치
					  항상 안정적인 상태를 유지해야 하는 브랜치(보통 master로 사용)
	- 토픽 브랜치 ㅡ> 버그 수정이나 기능추가 등의 단위작업을 위한 브랜치
	- HEAD ㅡ> 현재 사용중인 브랜치의 선두 부분을 나타내는 이름
		 	 'HEAD'를 이동하면, 사용하는 브랜치가 변경된다.
	- stash ㅡ> 파일의 변경 내용을 일시적으로 기록해두는 영역
		  ex) 체크아웃 시 커밋하지 않은 변경내용 중 전환된 브랜치에서 이미 변경된 기록이 있을 경우
		      충돌이 일어날 수 있는데, 이 경우 stash로 변경 내용을 다른 곳에 저장 ㅡ> 충돌을 피한 후
		      체크아웃을 하면 된다.
	● merge와 rebase의 차이점
		merge				rebase
	변경내용의 이력이 모두 남아있기 / 이력은 단순해지지만, 원래의 커밋 이력이 변경됨.
	때문에 이력이 복잡해짐		/ 정확한 이력을 남겨야 할 필요가 있을 경우에는
					  			사용하면 안됨.
	* rebase : 토픽 브랜치에 통합 브랜치의 최신 코드를 적용할 경우에 사용
	* merge : 통합 브랜치에 토픽 브랜치를 불러올 경우에는 우선 rebase를 한 후 merge
	● develop 브랜치 ㅡ> 통합 브랜치의 역할을 하며, 평소에는 이 브랜치를 기반으로 개발진행

ER Diagram
	- 우리는 구조화된 데이터를 저장하기 위해 데이터베이스를 사용
	  이 데이터의 구조 및 그에 수반한 제약 조건들은 다양한 기법에 의해 설계될 수 있다.
	  그 기법 중 하나가 개체-관계 모델링(ERM), ERM프로세스의 산출물이 개체-관계 다이어그램(ERD)
	- 개념적 데이터 모델 혹은 시맨틱 데이터 모델의 한 타입이다.
	● ERD의 논리설계단(모델) - 의미명(한글이나 알아보기 쉬운 단어로 표현)
				 			  엔티티와 엔티티타입, 관계를 정의, 어떠한 정보를 객체화할 것인가에 대한 규정
				 			  물리 dbms벤더에 종속되는 최종과정
	● ERD의 물리설계단 - 실제 컬럼명
			   			각 엔티티 관계에 의해서 나오는 테이블 등 실제로 dbms에 생성될 테이블들이 설계
			   			논리모델이 실제 dbms에 적용시키는 상세화 과정
	툴 - er-win
Bootstrap
	- 동적인 웹 사이트 및 응용 웹 개발을 위한 프론트엔드 프레임워크
	- 입력 창, 버튼, 다양한 레이아웃 등을 HTML/CSS 기반의 디자인 템플릿으로 제공
		ㅡ> 손쉬운 웹페이지 제작
	오픈소스로 공개되어 있어 사용자의 목적에 따라 커스터마이징 및 재배포 가능
	장점 ㅡ> 
    	 - 기본적인 틀, 구현된 컴포넌트 사용법을 익히고 사용한다면 쉽게 사용가능
		 - 기본적으로 반응형 페이지를 지원하고 있다.
	단점 ㅡ> 
    	 - 작업속도나 생산성면에 있어서는 효율적일 수 있으나 사용자 입맛에 맞게
		   수정하기 위해서는 부트스트랩에 구현된 기능을 수정할 필요가 있으므로
		   비효율적일 수 있음
		 - IE8의 지원을 위해 많은 부분을 JavaScript에 의존하는 경향이 크기 때문에 무겁다.
RESTful API
JSON
Responsive Web
Bitbucket
