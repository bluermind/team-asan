키워드 
NodeJS, ORM, Sequelize, MVC, MariaDB, Git, Bitbucket, ER Diagram,
Angular JS, Express, Bootstrap, RESTful API, JSON, Responsive Web
==========================================================================

# ● Node.JS (서버사이드 언어 : 스크리트 언어 중에서 서버사이드에서 실행되는 스크립트 언어)

- node.js는 구글이 개발하여 현재 크롬브라우저에 탑재되어 있는 Javascript 엔진인 V8을 기반으로 만들어진 Serverside Javascript이다.
- 서버용 웹 개발을 위한 오픈소스 환경
- 서버환경에서 애플리케이션을 작성할 수 있도록 도와준다.

## V8 자바스크립트 엔진
- 구글이 크롬 웹브라우저를 개발하면서 함께 개발한것이 V8 자바스크립트 엔진이다.
V8은 자바스크립트 처리 속도가 기존에 웹브라우저에 포함된 엔진들보다 월등히 빨랐다.
자바스크립트의 엔진들은 바이트코드를 변환하거나, 인터프리터하여 처리하였지만, V8은 JIT 컴파일 방식을 사용하여
성능을 획기적으로 개선했다.


## Node의 특징

1. Chrome JavaScript Engine V8 기반의 서버 플랫폼 -> Javascript를 compile 하여 native machine code 변경후 runtime 시 다시 최적화

2. 빠르고 확장이가능한 Network 프로그램 개발에 특화( TCP, UDP 관련 프로그램 개발 가능)

3. Single Thread 기반의 Non-Blocking I/O model 사용(비동기적 방식)

4. Event Driven Programming Model

5. 노버퍼링 : 버퍼링이 없으며 데이터를 CHUNK로 출력





## Node의 장 단점

장점 :  Single Thread 기반의 Event Callback 방식 처리로 인해 대용량의 Request를 받아들일 수 있다.
	프론트엔드와 백엔드를 자바스크립트라는 같은 언어로 다같이 관리가능
	성능이 매우 빠른 고성능 서버이며 확장성이 좋다.
	socket.io 모듈을 이용한 소켓프로그래밍이 매우 쉽다.


단점 :  CPU intensive 한 영역에서는 약하다.
	해당 코드가 수행되어야 코드에서 에러가 나는지를 확인할 수 있고, 에러가 날 경우 프로세스 자체가 내려가기 때문에 주의해야 한다.
	기술의 역사가 짧아 모듈의 완성도 등이 타 언어에 비해 부족하다.
	Single Thread 모델이기 때문에 하나의 작업 자체가 시간이 많이 걸리면, 전체 시스템의 성능이 급격하게 떨어질 수 있다.

### JIT 컴파일 방식
- 자바스크립트를 인터프리트 하지 않고 실행 즉시 기계어로 컴파일한다.


### Node의 특징인 Single Thread 기반
기존의 WAS들이 Thread 기반이기에 동시에 수많은 사용자의 Request가 들어오고 시간이 오래걸리는 File, Network I/O 가 해당로직에
존재하는 경우 기존의 Thread 기반의 WAS에서는 속도가 느려질 수 밖에 없었다. 왜냐면, File, Network등의 작업이 끝나 Response를 던져 줄때가지
Thread pool을 점유하고 있기 때문에 뒤늦게 Request를 날린 사용자가 Response를 주고 해당 Thread pool에 대한 점유를 끝낼때가지 대기햐야 한다.

ㅡ> 그러나 Node의 등장으로 인해서
Event call back 을 이용한 Node는 기존의 WAS와는 다르게 시간이 오래걸리느 File, Network I/O에 대해 Non-block 되도록 비동기로 처리하고
오랜 그들의 작업이 끝내면 작업이 완료되었다는 신호를 받아 처리한다.
그러다 보니 기존이 Thread 기반의 WAS에 비해 동시 Request를 더 많이  받을 수 있다는 장점이 있다.


# ● Express

- Express는 자바스크립트 기반으로 node.js 실행환경에서 호스트된 웹 프레임 워크이다.
- NodeJS를 위한 빠르고 개방적이고 간결한 웹 프레임워크
- Node.js 의 MVC 모듈이 Express 

## Exprses의 핵심
- 라우터 자체에 미들웨어나 조건들을 끼워넣고 순서대로 순환해가며 처리하는 것

## Express의 특징
- 정규식을 지원하는 강력한 라우팅 메커니즘
- 심플한 라우트 필터링
- 미들웨어 아키텍처를 활용하며 다양한 데이터 출력지원
- 다중으로 템플릿 엔진을 허용하는 간단한 변수전달 뷰 시스템

View = ejs 파일
Controller = 라우터

** Package.json의 dependencies 에 "express" : "*" 추가해줌. pom.xml과 비슷


# ● ORM
- 설계된 데이터베이스와 객체와의  관계에 대한 설정등을 포함하여 보다 객체지향적인 시스템의 완성을 위한 도구
- OOP 언어와 RDBMS의 시스템을 매핑하여 쉽게 데이터관련 OOP 프로그래밍을 하도록 하기 위한 기술
- 객체지향 애플리케이션은 객체지향대로 다루고, 관계형 데이터베이스는 관계형 데이터베이스대로
  설계하고 사용할 수 있도록 중간에서 도와주는 기술

## ORM의 특징
- 특정 DBMS에 종속되지 않는다.
- SQL문이 코드에 들어가지 않는다.
- 중첩 데이터를 바인딩해준다.

## ORM의 장·단점
장점 : 
- 개발자가 OOP나 CBD에 의한 개발에만 집중가능
- RDBMS관련 부분의 고려사항 최소화
- OOP언어/CBD개발 방법론에서 클래스나 컴포넌트 설계 및 개발에서 이질적인 RDBMS 관련된 부분을 최소화하고
  원 제품의 로직 구현에 충실하고자 하는 의도에서 나온 산물
- 생산성이 높아지고 캐시 등 다양한 저장소를 활용하기에 유연한 구조를 만들어 준다.
- 탑다운(Top-down)방식의 설계를 채택할 수 있는 경우 장점이 극대화 된다.

단점 :
- 퍼포먼스가 느리고 튜닝이 어렵다.
- 현실적으로 자바계층에 맞춰 DB스키마를 설계할 수 없는 프로젝트가 상당히 많으며
  이런 경우, ORM을 염두에 두지 않고 설계된 리거시 스키마를 그대로 두고 바텀업(bottom-up)방식으로 
  구현하는 접근을 할 수 밖에 없기에 ORM의 장점이 상당히 퇴색
- ORM기술 자체도 최적화나 복잡도, 또는 추상화 등의 이유로 꾸준히 비판받아왔다. 
- 현재는 ORM을 사용하지 않고도 영속성 문제를 깔끔하게 처리할 수 있는 대안도 존재한다.

### Node js의 ORM
- Sequelize, Bookshelf.js, node-orm2
- Sequelize.js는 Node.js 기반의 ORM이다. 

### Sequelize ORM : Node.js의 ORM 으로 객체와 모델을 매핑하고 Promise기반으로 동작
프로그래밍 언어로 직접 데이터베이스에 말할 수 없기 때문에 중간에 통역인 ORM 데이터 베이스가 알아들을 수 있는 언어로 번역하여 전달하는 것이다.

** Promise 란?
비동기 작업방식을 약속하는 것 ㅡ> Pending, fulfilled, rejected 상태 존재


# ● Sequalize
- Node.js 기반의 ORM이다. 공식적으로 PostgreSQL, MySQL, MariaDB, SQLite, MS-SQL을 지원한다.
- 모델을 정의하면 편리하게 createdAt, updatedAt 필드를 자동으로 만들어준다.
- 보통 RDB에서 사용하는 데이터 타입은 모두 지원한다.

## 장점
Node의 타 ORM에 비해 GitHub 레포지스토리 스타 수도 가장 많고 활성화된 사용자 수가 가장 많다.

# ● Maria DB
- 오픈소스의 관계형 데이터베이스 관리시스템(RDBMS)
- Mysql 코어를 가지고 분리개발 한 것
- Mysql의 모든 명령어, 인터페이스, 라이브러리와 같은 API가 MariaDB에도 존재하며 MariaDB는 사실상 MySQL의 완벽한 대체제
- MySQL과 동일한 소스코드를 기반으로 하며, GPL, v2라이센스를 따른다.

## MySql과 호환성
- 데이터와 테이블 정의 파일(.fmt) 파일이 바이너리 호환이 된다.
- 모든 파일이름과 바이너리, 경로, 포트 , 소켓 그리고 기타 등등이 동일하다
- 모든 MySQL 커넥터가 마리아 DB와 동일하게 작동한다.


성능 - 마리아 DB는 MySQL과 비교해 애플리케이션 부분 속도가 약 4~5천배정도 빠르며, MySQL이 가지고 있는 모든제품의 기능을 완벽히 구현
기능 - 쓰레드 풀 기능이 내장됐으며, 스토리지 엔진을 활용한 샤딩기술을 제공한다.

## mysql과의 비교·장점
- 월등히 빠른 쿼리 타임을 들수 있다.
- 다양한 기능과 엔진이 추가되었다.
	- Microseconds in MariaDB  : 테이블을 생성할 때 시간관련 자료형에 정밀도를 설정할 수 있다.
	  정밀도는 0부터 6 까지 설정할 수 있으며, 설정된 값만큼의 microseconds
- 다양한 Storage Engine을 지원한다.
- 2배 가량 퍼포먼스가 개선되었다.


# ● MVC
- 디자인 패턴 중 하나로써 하나의 프로젝트를 Model - View - Controller 세 가지의 역할로 구분한 패턴

Model : 객체 데이터, DB쿼리를 통한 데이터
	애플리케이션의 정보 즉 데이터를 담당하며 데이터의 가공을 책임지는 컴포넌트
View : 사용자에게 보여지는 화면
       클라이언트 측 기술인 HTML/CSS/JavaScript를 모아둔 컨테이너
Controller : View 와 Model을 연결, 비즈니스 로직을 담당

## MVC 를 왜 사용할까?
- Model, View, Controller 서로 영향을 받지 않는 3가지로 분리하여 각자의 역할에 집중할 수 있게끔 개발 가능

## MVC 의 장·단점
장점 :
- 애플리케이션의 확장성, 유지보수성, 유연성이 증가하고 중복코딩을 줄일 수 있다.
- 유연성 ㅡ> 새로운 요구사항에 대해 최소한의 비용으로 보다 유연하게 대처할 수 있는 것

단점 :
- View가 Model을 이용하기에, 서로간의 의존성을 완벽히 피할 수 없다.

### Node.JS / MVC프레임워크 - Express.js(모듈)


# ● AngularJS 
- 구글에서 만든 자바스크립트 프레임워크
- HTML을 확장시켜 동적인 Application을 지원하며 데이터가 변경함에 있어 자동적으로 AngularJS에서 UI요소를 만들고
  데이터 필터링 / 소팅 등 많은 기능을 제공

## AngularJS 특징
- 핵심기능으로써 양방향 데이터바인딩 기능

- 자바스크립트로 작성할 코드량을 줄여준다.
	- Dom을 선택하고 조작하는 자바스크립트 코드를 작성하지 않아도 된다.
- 양방향 데이터 바인딩이 가능하다.
	- 모델의 데이터와 뷰 데이터가 양방향 데이터 바인딩이 되어, 모델이 바뀌면 뷰데이터도 같이 변경된다.

3. HTML, CSS 로직 등 개발 영역을 명확하게 분리해준다.
	- 기존 자바스크립트에서는 Dom 조작과 이벤트 처리를 위해 HTML을 잘 알고 있어야 했으나, AngularJS는 뷰코드와 로직 코드가 명확하게 분리된다.


## Scope / Model / View / Controller / Directives(지시자)

Scope(스코프)	- 뷰와 컨트롤러 사이에서 데이터를 연결해주는 역할
		- 모델과 뷰를 감시하고, 컨트롤러에 이벤트를 보내는 역할

Model (모델) 	- 단순 자바스크립트 객체로 된 데이터
		- Scope는 항상 모델을 참조하고 있다.
		- 보통  JSON으로 표현되는 애플리케이션의 특정한 데이터 구조를 말한다.
		- json 데이터를 jQuery의 $.ajax메서드를 래핑한 Angular의 $http 를 통해 XHR로 서버에서 가져오거나 페이지를 로딩 할때, 코드에서
		  직접 (데이터베이스에서) 읽어오도록 할 수 있다.

View(뷰)	- 템플릿과 모델이 합쳐져서 보여지는 화면 (DOM구조로 되어 있음)
		- MVC 프레임워크를 사용한다면 뷰를 갱신할 모델 데이터를 내려 받은 뒤 Html에서 해당 데이터를 보여줄 것이다.

Controller	- 자바스크립트로 된 로직 영역
		- Scope에 model과 function을 정의해주는 역할 ㅡ> View가 이것들을 사용
		- 컨트롤러는 서버에서 직접 뷰로 접근하는 일종의 중간 통로로서 필요할 때마다 서버와 클라이언트 통신으로 데이터를 변경한다.
		- DOM 렌더링 정보가 일체 없다.

Directive(지시어) - HTML을 확장하는 AngularJS의 지시어
		    - ex) 데이터 바인딩을 위한 중괄호 표기 {{}}
			  ng-app, ng-controller, ng-click 등


Data Binding(데이터 바인딩) - 모델과 뷰의 데이터를 실시간으로 연동

Module(모듈) - 모든 자바스크립트 기능들이 ng-app="모듈명"을 시작으로 모듈 단위로 관리
	     - 컨트롤러, 서비스, 필터 등을 포함하며, 응용프로그램의 서로 다른 기능을 구성하는 컨테이너


Service(서비스) - 특정 기능을 담당하는 객체
		- 싱글톤 객체로 인스턴스가 하나만 존재한다.

# ● Git

## Git의 사용목적 : 
- 여러명이 공유한 파일을 동시에 편집하여, 충돌이 나지 않도록 하기 위해서
- 어느파일이 최신인지, 어떤부분이 변경된지를 파악하기 위해서

## Git(분산형 버전관리 시스템)의 이점
- 소스코드가 변경된 이력을 쉽게 확인 할 수 있다.
- 특정 시점에 저장된 버전과 비교하거나, 특정시점으로 되돌아 갈 수있다.


## 원격저장소와 로컬저장소
원격 저장소 : 파일이 원격저장소 전용 서버에서 관리되며, 여러사람이 함께 공유하기 위한 저장소
로컬 저장소 : 내 PC에 파일이 저장되는 개인전용 저장소

커밋 : 파일 및 폴더의 추가/변경사항을 저장소에 기록 -> 이전상태부터 현재상태까지의 변경이력이 기록됨


작업트리 --------------- 인덱스 ------------------------저장소

커밋은 작업트리에 있는 변경내용을 저장소에 바로 기록하는 것이 아니라, 그사이의 공간인 인덱스에 파일 상태를 기록(stage)
	-> 내가 원하는 일부변경사항만 , 인덱스에 등록해 커밋할 수 있다.

## 주요개념
### Push
- 내 PC의 로컬 저장소에서 변경된 이력을 원격저장소에 공유하려면, 로컬저장소의 변경 이력을 원격저장소에 업로드해야 합니다.
- 원격저장소에 내 변경이려기 업로드 되어, 원격저장소와 로컬저장소가 동일한 상태가 된다.

### Clone
- 누군가의 변경이력이 적용된 원격저장소가 있다면, 그걸 웹에서 통째로 복제해와 내 PC에서 작업할 수 있다.


### Pull
- 원격저장소를 공유해 여러사람이 함께 작업을 하면, 모두가 같은 원격저장소에 Push합니다.
- 원격저장소에서 로컬저장소로 업데이트를 하는 것을 풀(Pull)을 실행합니다.

### Branch
- 여러개발자들이 동시에 다양한 작업을 할 수 있게 만들어주는 기능
- 각자 독립적인 작업 영역(저장소) 안에서 마음대로 소스코드를 변경할 수 있음
- 이렇게 분리된 작업영역에서 변경된 내용은 나중에 원래의 버전과 비교해서 하나의 새로운 버전으로 만들어 낼 수 있다.

-> 메인브랜치에서 자신의 작업 전용브랜치를 만든다음, 각자 작업을 진행한 후 , 작업이 끝난사람은 메인브랜치에 자신의 브랜치의
   변경사항을 적용합니다. (다른사람의 작업에 영향을 받지 않고, 독립적으로 특정작업을 수행하고 그결과를 하나로 모아나감)

** master 브랜치
- 새로운저장소에 새로운 파일을 추가한다거나 추가한 파일의 내용을 변경하여 그내용을 저장

** 통합브랜치(master브랜치를 주로 통합브랜치로 쓴다.)
- 언제든지 배포할 수 있는 버전을 만들 수 있어야 하는 브랜치 -> 모든기능이 정상적으로 정상적으로 동작하는 상태

** 토픽브랜치 
- 기능추가나, 버그수정과 같은 단위 작업을 위한 브랜치 , 우리가 사용했던 브랜치들이 토픽브랜치

** 브랜치를 전환하기
- 처음에 Git을 설치하게 되면, master브랜치가 선택되어있고, 현재 선택된 브랜치가 아닌 다른 브랜치에서 작업하고 싶을때
  체크아웃 명령어를 실행하여 원하는 브랜치로 전환할 수 있습니다.

- 체크아웃을 실행하면, 우선 브랜치 안에 있는 마지막 커밋내용이 작업트리에 펼쳐지게 됩니다. 
  브랜치가 전환되었으므로, 이후 실행한 커밋은 전환한 브랜치에 추가됩니다.

### stash
- 파일의 변경 내용을 일시적으로 기록해두는 영역
	ex) 체크아웃 시 커밋하지 않은 변경내용 중 전환된 브랜치에서 이미 변경된 기록이 있을 경우
	    충돌이 일어날 수 있는데, 이 경우 stash로 변경 내용을 다른 곳에 저장 ㅡ> 충돌을 피한 후
	    체크아웃을 하면 된다.

### HEAD
- 현재 사용중인 브랜치의 선두 부분을 나타내는 이름
- HEAD를 이동하면, 사용하는 브랜치가 변경된다.

** HEAD~1 		1세대앞의 커밋
   HEAD~1^1 		1세대앞의 커밋이며, 첫번째원본

### 브랜치 통합 : merge, rebase
- 어느쪽을 사용하느냐에 따라 통합 후 브랜치 이력이 달라진다.

### merge
- 통합 브랜치에 토픽 브랜치를 불러올 경우에는 우선 rebase를 한 후 merge
fast-forward 병합 : master가 분기한 브랜치가 있을때, 분기한 브랜치로 master브랜치가 이동하여 분기브랜치의 내용을 적용할 수 있다.
non -fast-forward 병합 : master브랜치가 분기한 브랜치가 있고, 그이후 master브랜치가 변경내용이 있을때, 분기한 브랜치의 내용과
			하나로 통합할 필요가 있다.

### rebase
- 토픽 브랜치에 통합 브랜치의 최신 코드를 적용할 경우에 사용
non-fast-forward 에서  분기된 브랜치를 master브랜치 뒤로 이력을 이동하게 한다음, 이력이 하나의 줄기로 이어지면, 
master는 rebase하여, 분기된 브랜치로 병합하면 된다.

### merge와 rebase의 차이점
			merge						rebase
변경내용의 이력이 모두 남아있기 때문에 이력이 복잡해짐 / 이력은 단순해지지만, 원래의 커밋 이력이 변경됨.
						         정확한 이력을 남겨야 할 필요가 있을 경우에는
					  		 사용하면 안됨.


##### 변경되는 이력의 주의할 점
- 내가 pull을 실행한 후 다른 사람이 push를 하여 원격저장소를 업데이트 해버렸을 때, 나의 push요청이 거부되어 버린다.
  이런경우 Merge(병합) 이라는 작업을 진행해서, 다른 사람의 업데이트 이력을 내저장소에도 갱신해야 한다.
  만약 병합하지 않은채로 이력을 덮어스게 되면, 다른 사람이 push한 업데이트내역이 사라져 버린다.

##### 팀마다 다른 운용
- 토픽 브랜치에 통합 브랜치의 최신 코드를 적용할 경우에는 rebase 를 사용,
- 통합 브랜치에 토픽 브랜치를 불러올 경우에는 우선 rebase 를 한 후 merge

-  --amend 옵션을 지정하여 커밋을 수행하면 같은 브랜치 상에서 이전에 커밋했던 내용에 새로운 내용을 추가하거나 설명을 수정
- revert 명령어를 이용하면, 특정 커밋의 내용을 삭제 할 수 있다.
- reset 명령어를 이용하면, 더이상 필요없어진 커밋들을 버릴 수 있다 명령어 실행시 어떤모드로 실행할 지 지정하여 HEAD 위치와 인덱스 , 작업트리 내용을 함께 되돌릴지 여부를 선택
- 커밋만 되돌리고 싶을때 (soft), 변경한 인덱스의 상태를 원래대로 되돌리고 싶을때 (mixed) , 최근의 커밋을 완전히 버리고 이전의 상태로 되돌리고 싶을 때(hard)


##### 다른브랜치로 부터 특정커밋을 가져와서 내브랜치에 넣기
- cherry-pick을 이용하면 다른 브랜치에서 지정한 커밋을 복사해서 현재 브랜치로 가져올 수 있다.





# ● Bitbucket 
- 분산버전 관리 툴인 Git을 사용하는 프로젝트를 지원하는 웹호스팅 서비스
- Github와 달리 private(비공개) 저장소도 무료로 사용할 수 있다.

## Bitbucket의 장·단점
장점 :
- 기존의 svn / git의 repository에 있던 것들을 주소와 계정정보만 가지고 손쉽게 옮겨올 수 있다.
- 프로젝트를 private로 진행할 수 있다.

단점 : 
- 무료 협업 팀원 제한이 5명 이하 이다.



# ● ER Diagram
- 데이터 모델링 분야 (개체 - 관계 모델) : 구조화된 데이터에 대한 일련의 표현
					  개체 타입과 이들간의 관계타입을 이용해 현실 세계를 개념적으로 표현한것.
## 구성요소
### Entity 
- 그냥 직사각형
### Weak entity 
- 직사각형 두개
### Relationship 
- 마름모
### Attribute 
- 타원형
### Multi-valued attribute
- 점있는 타원형

### 개체(엔티티)
- 분리된 물체 하나를 표현한다 , 명사에 해당된다

### 관계(릴레이션 쉽)
- 두 개 이상의 엔티티들이 어떻게 서로 연관되어 있는지


## ERD의 논리·물리설계단
### ERD 논리설계단(모델) 
- 의미명(한글이나 알아보기 쉬운 단어로 표현)
- 엔티티와 엔티티타입, 관계를 정의, 어떠한 정보를 객체화할 것인가에 대한 규정
- 물리 DBMS벤더에 종속되는 과정

### ERD 물리설계단
- 실제 컬럼명
- 각 엔티티 관계에 의해서 나오는 테이블 등 실제로 DBMS에 생성될 테이블들이 설계
- 논리모델이 실제 DBMS에 적용시키는 상세화 과정











# ● Bootstrap 
- 트위터에서 시작된 HTML5 기반의 오픈소스 웹 디자인 프레임워크로 각종 레이아웃, 버튼, 입력창 등의
  디자인을 css와 Javascript 로 만들어 놓은 것 ㅡ> 손쉬운 웹페이지 제작가능
- 동적인 웹 사이트 및 응용 웹 개발을 위한 프론트엔드 프레임워크

## Bootstrap의 장·단점
장점 :
- 글자, 인용문, 목록, 표, 입력폼, 버튼, 이미지, 아이콘, 드롭다운 메뉴, 버튼, 탭, 리스트, 메뉴바 등등
  웹페이지에서 많이 쓰이는 요소를 거의 내장하고 있다.
- 기본적인 틀, 구현된 컴포넌트 사용법을 익히고 사용한다면 쉽게 사용가능
- 웹브라우저에 크기에 따라 자동으로 정렬되는 그리드 시스템을 채용하고 있다. -> 반응형 웹 디자인을 지원한다.


단점 :
- 디자인이 정형화 되어 있기 때문에 비슷한 디자인의 페이지가 양산될 수 있다는 것
- 작업속도나 생산성면에서는 효율적일 수 있으나 사용자 입맛에 맞게 수정하기 위해서는
  부트스트랩에 구현된 기능을 수정할 필요가 있으므로 비효율적일 수 있다.
- HTML 5를 인식시키는 JavaScript 코드가 필요하고 , 3.0에서부터는 IE8 부터 지원한다.
- IE8의 지원을 위해 많은 부분을 JavaScript에 의존하는 경향이 크기 때문에 무겁다.



# ● Responsive Web
- 디자인과 개발이 화면 사이즈, 플랫폼 등을 기본으로 하여 사용자의 환경과 행동에 맞춰 반응하는 것
	
## 필요성
- 스마트폰, 태블릿 PC 등 다양한 스마트디바이스들이 등장하면서 디바이스별로 중복적으로
  화면을 만들지 않고 다양한 해상도/환경을 하나의 콘텐츠로 이용하고자 하는 니즈에서 탄생

## 기대효과
- 다양한 기기를 사용하는 사용자들을 만족시킬 수 있다.
- 웹사이트가 쉽게 읽고 따라올 수 있을 때 사용자들이 해당 페이지에 더 오래 머물면서
  컨텐츠를 살펴보고 구매나 예약 등의 서비스로 이어질 수 있음.
	ㅡ> 사용자의 만족도 / 영업 및 마케팅 촉진 
	



# ● RESTful API 
- 웹 설계의 우수성을 살려 웹의 장점을 최대한 활용할 수 있는 아키텍처

## REST의 기본요소 : 리소스, 메소드, 메세지
ex) 이름이 Terry 인 사용자를 생성한다 라는 호출
"사용자"는 리소스, "생성한다" 라는 행위는 메서드 그리고 이름이 "Terry"인 사용자는 메세지가 된다.


HTTP POST, http://myweb/users(리소스)
{
	"users":{
	   "name":"terry"
	}
}

와 같은 형태로 표현되며, 생성한다의 의미를 갖는 메서드는 HTTP Post 메서드가 되고, 생성하고자 하는 대상이 되는 사용자


## 리소스
- 접근할 대상, URI를 통해 식별
- REST는 리소스 지향 아키텍처 스타일이며, 명사로 표현하고, 각 세부 리소르에는 id를 붙인다.
- 즉, 사용자라는 리소스타입을 http://myweb/users라고 정의했다면, terry 라는 id를 갖는 리소스는
  http://myweb/users/terry라는 형태로 정의 할 수 있다.

HTTP Post, http://myweb/users/
{
	"name":"terry"
	"address":"seoul"
}


-> 리소스를 이름은 terry, 주소는 seoul이라는 내용(메세지)로 HTTP post를 이용해서 생성하는 정의


조회 : HTTP GET, http://myweb/users/terry (
수정 : HTTP PUT, http://myweb/users/terry
{
	"name":"terry",
	"address":"suwon"
}

삭제 : HTTP DELETE, http://myweb/users/terry
단순하게 리소스를 정의 해준다음에 id가 terry인 사용자의 정보를 삭제하는 방법이다.

- ex) URI
http://api.domain.com/books		ㅡ> 도서정보 컬렉션
http://api.domain.com/books/1		ㅡ> 1번 도서 정보
http://api.domain.com/books/1/photo 	ㅡ> 1번 도서의 사진
		
- 리소스명은 동사보다 명사를 활용, 어떤 자원인지 표현하는데 집중할 것
- URI 구성 예) /(컬렉션)/(아이템)/(컬렉션)/(아이템)/
		/sports/soccer/players/1/

## 메서드
- 리소스에 대한 행위, 표준 HTTP메소드에 따라 자원에 접근(생성, 조회, 수정, 삭제)
- REST에서 행위에 대한 메서드를 HTTP 메서드를 그대로 사용한다.
- 여러가지 메서드가 있지만, REST에서는 CRUD에 대한 4가지의 메서드만을 사용한다.

-	      HTTP 메소드		/ 	자원에 대한 행위
		  
		  POST			/	자원 생성 (Create)
		  GET			/ 	자원 조회 (Read)
		  PUT			/	자원 수정 (Update)
		  DELETE		/ 	자원 삭제 (Delete)
		
		- Endponit
		URI별 HTTP 메소드로 구현된 항목
		
		ex)
		HTTP메소드		URI(자원)		Endponit의 행위
		POST	 http://api.domain.com/books/		새로운 도서정보 생성
		GET	 http://api.domain.com/books/		도서정보 목록 조회
		GET	 http://api.domain.com/books/1/		1번 도서정보 조회
		PUT	 http://api.domain.com/books/1/		1번 도서정보 수정
		DELETE	 http://api.domain.com/books/1/		1번 도서정보 삭제


Idempotent(Yes/No)
Post(Create) No , Put(Update) Yes, Get(Select) Yes, Delete(Delete) Yes
Idempotent는 여러번 수행해도 결과가 같은 경우를 의미한다.

Post의 경우에는 리소스를 계속 생성하는 경우이기 때문에 Idempotent하지 않다
Get의 경우에는 게시물의 조회수를 카운트 해주는 기능은 Idempotent하지 않은 메서드로 정의해야한다.

## 메세지
- HTTP 헤더와 바디에 포함된 메세지는 메세지를 처리하기 위한 충분한 정보를 포함
- RSET에서 자원에 대한 정보는 HTTP 바디와 HTTP 헤더, 응답 상태코드를 활용

- HTTP 바디
HTTP 바디에 포함된 데이터를 통해 자원에 대한 정보를 전달한다.
데이터 포맷으로는 JSON을 많이 사용, XML / 사용자정의 포맷을 정해서도 사용 가능
		
- HTTP 헤더
HTTP 바디의 컨텐츠 종류를 명시할 수 있다.
헤더에 정의된 컨텐츠 타입에 따라 데이터를 분석하도록 구현해야 한다.
요청 HTTP 헤더 ㅡ> Accept 항목
응답 HTTP 헤더 ㅡ> Content-type 으로 컨텐츠 타입을 설명
	
- 컨텐츠 타입 종류
* application/json
* application/xml
* text/plain
* image/jpeg
* image/png

** Content Type 란? 
request에 실어보내는 데이터 타입의 정보를 표현


## REST의 제약조건(특징/모두 만족 시 Restful하다고 함)
- 인터페이스 일관성(Uniform Interface)
HTTP 표준에만 따른다면, 어떤한 기술도 사용이 가능한 인터페이스
아키텍처를 단순화하고 분리해 각 부분을 독립적으로 발전시킬 수 있음

- 무상태성/ 스테이트리스
HTTP Session 과 같은 컨텍스트 저장소에서 상태정보를 저장하지 않는 형태, API 서버는 들어오는
요청만을 들어오는 메세지로 처리, 세션과 같은 컨텍스트 정보를 신경쓰지 않아도 된다.

- 캐쉬(Cacheable) 
HTTP라는 기존의 웹표준을 그대로 사용하기 때문에, 웹에서 사용하는 기존의 인프라를 그대로 활용이 가능하다.

- 자체표현구조
API메세지 자체만 보고도 API를 이해할 수 있는 표현구조를 갖는다.

- 계층화(Layered system)
서버를 다중 계층으로 구성할 수 있음. 비즈니스 로직을 수행하는 API 서버,
그 앞단에 사용자 인증, 암호화, 로드밸런싱 등의 계층을 추가해 구조상의 유연성 제공

- Client <ㅡ> Server 구조
REST서버는 API를 제공하고, 제공된 API를 이용해서 비즈니스 로직 처리 및 저장을 책임진다.
클라이언트와 서버의 역활이 명확하게 구분된다.

- 확장성 및 보안성 향상

- Code on demand
서버에서 스크립트를 통해 클라이언트 부분 수행가능
**  예시) GET www.plus.co.kr/images/main HTTP/1.1 Accept:image/jpg
	  HTTP메소드와 URI로 원하는 내용을 모두 표현하는것.

** REST는 어떤 자원(리소스)에 대한 어떤 행위(메소드)를 어떻게(메세지)할 지 HTTP기반으로 정해놓은 아키텍처

## 단점
- 표준이 없음
- RDBMS와 어색함(NoSQL과 잘맞음)
- HTTP한계에 묶인다.



# ● JSON(JavaScript Object Notation) 

- 속성 - 값 쌍으로 이루어진 데이터 오브젝트 교환 포맷의 일종이다
- XML에 비해 경량화된 데이터 교환포맷으로 기존의 XML을 가볍게 만든것이다.
- Ajax로 서버와 통신하며, 데이터를 주고 받을 때, 데이터 교환을 쉽게 하기 위해 JSON을 사용한다.


## 기본형태

{
	"age":29,
	"name":"JIWOO"

}

주고 받을 수 있는 자료형은 숫자, 문자열, boolean, 배열, 객체이며, 기본데이터 배열은 key, 와 value로 구성되어있으며, 중괄호로 감싼다


## 특징
- 문자열을 사용하므로, 오버헤드가 거의 없다.
- 프로그래밍 언어에 독립적이므로 서로 다른 시스템 간에 객체를 교환하기에 좋다.
- 최신브라우저는 대부분 JSON 파서를 내장하므로 사용하기가 편리하다
- 자바스크립트 문법을 사용해서 eval명령의 사용이 가능하다.


## 저장되는 형태 3가지

- 중괄호 ({})로 시작, 끝을 표시
- 배열 대괄호 안에 콤마로 값, 순서구분 ex) ["오라클자바커뮤니티",2312312,{"이름":"오라클자바커뮤니티"},[821312,"오라클자바커뮤니티"]]
- 기본자료형 : 숫자, 문자열, 논리형, null, 네가지 타입을 지원, 날짜, 시간, 화폐 등은 지원안함

## 단점
- 상호호환성과 이종 시스템들간의 이해를 방해하지 않기 위해 주석, 코멘트를 권장하지 않음
  (JSON의 단점을 보완한 것으로 JSON5가 있음)