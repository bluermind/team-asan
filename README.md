# team-asan
아산멤버들의 아이디어 정리 공간


## 마크다운 사용법

https://gist.github.com/ihoneymon/652be052a0727ad59601



------------------------------------------------- 박지우 ----------------------------------------------------------
Git의 사용목적 : 
1. 여러명이 공유한 파일을 동시에 편집하여, 충돌이 나지 않도록 하기 위해서
2. 어느파일이 최신인지, 어떤부분이 변경된지를 파악하기 위해서

Git(분산형 버전관리 시스템)의 이점
1. 소스코드가 변경된 이력을 쉽게 확인 할 수 있다.
2. 특정 시점에 저장된 버전과 비교하거나, 특정시점으로 되돌아 갈 수있다.


원격저장소와 로컬저장소
원격 저장소 : 파일이 원격저장소 전용 서버에서 관리되며, 여러사람이 함께 공유하기 위한 저장소
로컬 저장소 : 내 PC에 파일이 저장되는 개인전용 저장소


커밋 : 파일 및 폴더의 추가/변경사항을 저장소에 기록 -> 이전상태부터 현재상태까지의 변경이력이 기록됨


작업트리 --------------- 인덱스 ------------------------저장소

커밋은 작업트리에 있는 변경내용을 저장소에 바로 기록하는 것이 아니라, 그사이의 공간인 인덱스에 파일 상태를 기록(stage)
	-> 내가 원하는 일부변경사항만 , 인덱스에 등록해 커밋할 수 있다.


push
-> 내 PC의 로컬 저장소에서 변경된 이력을 원격저장소에 공유하려면, 로컬저장소의 변경 이력을 원격저장소에 업로드해야 합니다.
-> 원격저장소에 내 변경이려기 업로드 되어, 원격저장소와 로컬저장소가 동일한 상태가 된다.



clone
누군가의 변경이력이 적용된 원격저장소가 있다면, 그걸 웹에서 통째로 복제해와 내 PC에서 작업할 수 있다.


Pull
원격저장소를 공유해 여러사람이 함께 작업을 하면, 모두가 같은 원격저장소에 Push합니다.
원격저장소에서 로컬저장소로 업데이트를 하는 것을 풀(Pull)을 실행합니다.


backlog.com
id : parkjiwoo
password : ab991122


변경되는 이력의 주의할 점
내가 pull을 실행한 후 다른 사람이 push를 하여 원격저장소를 업데이트 해버렸을 때, 나의 push요청이 거부되어 버린다.
-> 이런경우 Merge(병합) 이라는 작업을 진행해서, 다른 사람의 업데이트 이력을 내저장소에도 갱신해야 한다.
-> 만약 병합하지 않은채로 이력을 덮어스게 되면, 다른 사람이 push한 업데이트내역이 사라져 버린다.


브랜치
여러개발자들이 동시에 다양한 작업을 할 수 있게 만들어주는 기능
각자 독립적인 작업 영역(저장소) 안에서 마음대로 소스코드를 변경할 수 있음
이렇게 분리된 작업영역에서 변경된 내용은 나중에 원래의 버전과 비교해서 하나의 새로운 버전으로 만들어 낼 수 있다.

-> 메인브랜치에서 자신의 작업 전용브랜치를 만든다음, 각자 작업을 진행한 후 , 작업이 끝난사람은 메인브랜치에 자신의 브랜치의
   변경사항을 적용합니다. (다른사람의 작업에 영향을 받지 않고, 독립적으로 특정작업을 수행하고 그결과를 하나로 모아나감)




master 브랜치
새로운저장소에 새로운 파일을 추가한다거나 추가한 파일의 내용을 변경하여 그내용을 저장


통합브랜치(master브랜치를 주로 통합브랜치로 쓴다.)
언제든지 배포할 수 있는 버전을 만들 수 있어야 하는 브랜치 -> 모든기능이 정상적으로 정상적으로 동작하는 상태


토픽브랜치 
기능추가나, 버그수정과 같은 단위 작업을 위한 브랜치 , 우리가 사용했던 브랜치들이 토픽브랜치


브랜치를 전환하기
처음에 Git을 설치하게 되면, master브랜치가 선택되어있고, 현재 선택된 브랜치가 아닌 다른 브랜치에서 작업하고 싶을때
체크아웃 명령어를 실행하여 원하는 브랜치로 전환할 수 있습니다.

체크아웃을 실행하면, 우선 브랜치 안에 있는 마지막 커밋내용이 작업트리에 펼쳐지게 됩니다. 
브랜치가 전환되었으므로, 이후 실행한 커밋은 전환한 브랜치에 추가됩니다.


HEAD
현재 사용중인 브랜치의 선두부분을 나타내는 이름입니다. 기본적으로 master의 선두부분을 나타냅니다.
HEAD를 이동하면, 사용하는 브랜치가 변경됩니다.

HEAD~1 		1세대앞의 커밋
HEAD~1^1 	1세대앞의 커밋이며, 첫번째원본


stash
파일의 변경내용을 일시적으로 기록해두는 영역.
stash를 사용하여, 작업트리와 인덱스내에서 아직 커밋하지 않은 변경을 일시적으로 저장해둘 수 있습니다.
stash에 저장된 변경내용은 나중에 다시 불러와 원래의 브랜치나 다른 브랜치에 커밋할 수 있습니다.




브랜치 통합 : merge, rebase가 있다 -> 어느쪽을 사용하느냐에 따라 통합후 브랜치이력이 달라진다.


merger
fast-forward 병합 : master가 분기한 브랜치가 있을때, 분기한 브랜치로 master브랜치가 이동하여 분기브랜치의 내용을 적용할 수 있다.
non -fast-forward 병합 : master브랜치가 분기한 브랜치가 있고, 그이후 master브랜치가 변경내용이 있을때, 분기한 브랜치의 내용과
			하나로 통합할 필요가 있다.

rebase
non-fast-forward 에서  분기된 브랜치를 master브랜치 뒤로 이력을 이동하게 한다음, 이력이 하나의 줄기로 이어지면, 
master는 rebase하여, 분기된 브랜치로 병합하면 된다.



팀마다 다른 운용
토픽 브랜치에 통합 브랜치의 최신 코드를 적용할 경우에는 rebase 를 사용,
통합 브랜치에 토픽 브랜치를 불러올 경우에는 우선 rebase 를 한 후 merge





-  --amend 옵션을 지정하여 커밋을 수행하면 같은 브랜치 상에서 이전에 커밋했던 내용에 새로운 내용을 추가하거나 설명을 수정
- revert 명령어를 이용하면, 특정 커밋의 내용을 삭제 할 수 있다.
- reset 명령어를 이용하면, 더이상 필요없어진 커밋들을 버릴 수 있다 명령어 실행시 어떤모드로 실행할 지 지정하여 HEAD 위치와 인덱스 , 작업트리 내용을 함께 되돌릴지 여부를 선택
	-커밋만 되돌리고 싶을때 (soft), 변경한 인덱스의 상태를 원래대로 되돌리고 싶을때 (mixed) , 최근의 커밋을 완전히 버리고 이전의 상태로 되돌리고 싶을 때(hard)


다른브랜치로 부터 특정커밋을 가져와서 내브랜치에 넣기
cherry-pick을 이용하면 다른 브랜치에서 지정한 커밋을 복사해서 현재 브랜치로 가져올 수 있다.





NodeJS, ORM, Sequelize, MVC, MariaDB, Git, Bitbucket, ER Diagram,
Angular JS, Express, Bootstrap, RESTful API, JSON, Responsive Web


nodejs 공부(서버사이드 언어 : 스크리트 언어 중에서 서버사이드에서 실행되는 스크립트 언어)

node.js는 구글이 개발하여 현재 크롬브라우저에 탑재되어 있는 Javascript 엔진인 V8을 기반으로 만들어진 Serverside Javascript이다.


V8 자바스크립트 엔진
-> 구글이 크롬 웹브라우저를 개발하면서 함께 개발한것이 V8 자바스크립트 엔진이다.
V8은 자바스크립트 처리 속도가 기존에 웹브라우저에 포함된 엔진들보다 월등히 빨랐다
자바스크립트의 엔진들은 바이트코드를 변환하거나, 인터프리터하여 처리하였지만, V8은 JIT 컴파일 방싣을 사용하여
성능을 획기적으로 개선했습니다.


JIT 컴파일 방식
-> 자바스크립트를 인터프리트 하지 않고 실행 즉시 기계어로 컴파일한다.


Node의 특징인 Single Thread 기반

기존의 WAS들이 Thread 기반이기에 동시에 수많은 사용자의 Request가 들어오고 시간이 오래걸리는 File, Network I/O 가 해당로직에
존재하는 경우 기존의 Thread 기반의 WAS에서는 속도가 느려질 수 밖에 없었다. 왜냐면, File, Network등의 작업이 끝나 Response를 던져 줄때가지
Thread pool을 점유하고 있기 때문에 뒤늦게 Request를 날린 사용자가 Response를 주고 해당 Thread pool에 대한 점유를 끝낼때가지 대기햐야 한다.


ㅡ> 그러나 Node의 등장으로 인해서
Event call back 을 이용한 Node는 기존의 WAS와는 다르게 시간이 오래걸리느 File, Network I/O에 대해 Non-block 되도록 비동기로 처리하고
오랜 그들의 작업이 끝내면 작업이 완료되었다는 신호를 받아 처리한다.
그러다 보니 기존이 Thread 기반의 WAS에 비해 동시 Request를 더 많이  받을 수 있다는 장점이 있다.


Node의 특징

1. Chrome JavaScript Engine V8 기반의 서버 플랫폼 -> Javascript를 compile 하여 native machine code 변경후 runtime 시 다시 최적화

2. 빠르고 확장이가능한 Network 프로그램 개발에 특화( TCP, UDP 관련 프로그램 개발 가능)

3. Single Thread 기반의 Non-Blocking I/O model 사용(비동기적 방식)

4. Event Driven Programming Model





Node의 장 단점

장점 :  Single Thread 기반의 Event Callback 방식 처리로 인해 대용량의  Request를 받아들일 수 있다.
	socket.io 모듈을 이용한 소켓프로그래밍이 매우 쉽다.


단점 :  CPU intensive 한 영역에서는 약하다.
	해당 코드가 수행되어야 코드에서 에러가 나는지를 확인할 수 있고, 에러가 날 경우 프로세스 자체가 내려가기 때문에 주의해야한다



ORM
-> 설계된 데이터베이스와 객체와의  관계에 대한 설정등을 포함하여 보다 객체지향적인 시스템의 완성을 위한 도구



Node js의 ORM - Sequelize, Bookshelf.js, node-orm2
Sequelize.js는 Node.js 기반의 ORM이다. 

Sequelize ORM : 객체와 모델을 매핑
프로그래밍 언어로 직접 데이터베이스에 말할 수 없기 때문에 중간에 통역인 ORM 데이터 베이스가 알아들을 수 있는 언어로 번역하여 전달하는 것이다.





<Maria DB>
Maria DB - 오픈소스의 관계형 데이터베이스 관리시스템(RDBMS)
MySQL과 동일한 소스코드를 기반으로 하며, GPL, v2라이센스를 따른다.

MySql과 호환성
1. 데이터와 테이블 정의 파일(.fmt) 파일이 바이너리 호환이 된다.
2. 모든 파일이름과 바이너리, 경로, 포트 , 소켓 그리고 기타 등등이 동일하다
3. 모든 MySQL 커넥터가 마리아 DB와 동일하게 작동한다.


성능 - 마리아 DB는 MySQL과 비교해 애플리케이션 부분 속도가 약 4~5천배정도 빠르며, MySQL이 가지고 있는 모든제품의 기능을 완벽히 구현
기능 - 쓰레드 풀 기능이 내장됐으며, 스토리지 엔진을 활용한 샤딩기술을 제공한다.

mysql과 비교했을 때, 장점

1. 월등히 빠른 쿼리 타임을 들수 있다.

2. 다양한 추가 기능들이 있다.
	- Microseconds in MariaDB  : 테이블을 생성할 때 시간관련 자료형에 정밀도를 설정할 수 있다.
	  정밀도는 0부터 6 까지 설정할 수 있으며, 설정된 값만큼의 microseconds


3. 다양한 Storage Engine을 지원한다.






Bitbucket : 분산버전 관리 툴인 Git을 사용하는 프로젝트를 지원하는 웹호스팅 서비스 입니다
            Github와 달리 private(비공개) 저장소도 무료로 사용할 수 있습니다.




ER Diagram
데이터 모델링 분야 (개체 - 관계 모델) : 구조화된 데이터에 대한 일련의 표현
					개체 타입과 이들간의 관계타입을 이용해 현실 세계를 개념적으로 표현한것.

Entity - 그냥 직사각형
Weak entity - 직사각형 두개
Relationship - 마름모
Attribute - 타원형
Multi-valued attribute 점있는 타원형


개체(엔티티) : 분리된 물체 하나를 표현한다 , 명사에 해당된다
관계(릴레이션 쉽) : 두 개 이상의 엔티티들이 어떻게 서로 연관되어 있는지


Angular Js - 구글에서 만든 자바스크립트 프레임워크

Angular JS의 특징
1. 자바스크립트로 작성할 코드량을 줄여준다.
	- Dom을 선택하고 조작하는 자바스크립트 코드를 작성하지 않아도 된다.

2. 양방향 데이터 바인딩이 가능하다.
	- 모델의 데이터와 뷰 데이터가 양방향 데이터 바인딩이 되어, 모델이 바뀌면 뷰데이터도 같이 변경된다.

3. HTML, CSS 로직 등 개발 영역을 명확하게 분리해준다.
	- 기존 자바스크립트에서는 Dom 조작과 이벤트 처리를 위해 HTML을 잘 알고 있어야 했으나, AngularJS는 뷰코드와 로직 코드가 명확하게 분리된다.


주요개념

Model (모델) 	- 단순 자바스크립트 객체로 된 데이터
		- 보통  JSON으로 표현되는 애플리케이션의 특정한 데이터 구조를 말한다.
		- json 데이터를 jQuery의 $.ajax메서드를 래핑한 Angular의 $http 를 통해 XHR로 서버에서 가져오거나 페이지를 로딩 할때, 코드에서
		  직접 (데이터베이스에서) 읽어오도록 할 수 있다.

View(뷰)	- 템플릿과 모델이 합쳐져서 보여지는 화면 (DOM구조로 되어 있음)
		- MVC 프레임워크를 사용한다면 뷰를 갱신할 모델 데이터를 내려 받은 뒤 Html에서 해당 데이터를 보여줄 것이다.

Controller	-자바스크립트로 된 로직 영역
		- 컨트롤러는 서버에서 직접 뷰로 접근하는 일종의 중간 통로로서 필요할 때마다 서버와 클라이언트 통신으로 데이터를 변경한다.

Scope(스코프)	- 뷰와 컨트롤러 사이에서 데이터를 연결해주는 역활
		- 모델과 뷰를 감시하고, 컨트롤러에 이벤트를 보내는 역활


Directive(디렉티브) - html을 확장하는 AngularJS의 지시어
		    - ex) ng-app, ng-controller, ng-click 등


Data Binding(데이터 바인딩) - 모델과 뷰의 데이터를 실시간으로 연동

Moduel(모듈) - 모든 자바스크립트 기능들이 ng-app="모듈명"을 시작으로 모듈 단위로 관리
	     - 컨트롤러, 서비스, 필터 등을 포함하며, 응용프로그램의 서로 다른 기능을 구성하는 컨테이너


Service(서비스) - 특정 기능을 담당하는 객체
		- 싱글톤 객체로 인스턴스가 하나만 존재한다.




Express는 자바스크립트 기반으로 node.js 실행환경에서 호스트된 웹 프레임 워크이다. 


-------------------------------------------------------------------------------------------------------------------
