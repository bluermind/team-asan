# team-asan
?꾩궛硫ㅻ쾭?ㅼ쓽 ?꾩씠?붿뼱 ?뺣━ 怨듦컙


## 留덊겕?ㅼ슫혻?ъ슜踰?

https://gist.github.com/ihoneymon/652be052a0727ad59601

========================== ypLim ====================================
Node JS
	- 대표 ORM : Sequelize
Express
	- nodeJS를 위한 빠르고 개방적이고 간결한 웹 프레임워크
	- 일반적인 Web Application 기능을 포함하는, 
	  WebApp을 개발하는데 필요한 수많은 모듈을 집합하여 사용자가 쓰기 쉽도록 만들어 둔 모듈
	- 정규식을 지원하는 강력한 라우팅 메커니즘, 심플한 라우트 필터링
	- 미들웨어 아키텍처를 활용하며 다양한 데이터 출력지원
	- 다중으로 템플릿 엔진을 허용하는 간단한 변수전달 뷰 시스템
	** 핵심 ㅡ> 라우터 자체에 미들웨어나 조건들을 끼워넣고 순서대로 순환해가며 			처리해가는 것

ORM(Object Relational Mapping)
	- OOP언어와 데이터를 다루는 RDBMS와의 상이한 시스템을 매핑하여, 쉽게 
	   데이터관련 OOP프로그래밍을 하도록 하기 위한 기술이다.
	- 객체지향 애플리케이션은 객체 지향대로 다루고, 관계형 데이터베이스는 
	   관계형 데이터베이스대로 설계하고 사용할 수 있도록 중간에서 도와주는 기술

	- Ex) 		OOP				RDBMS
		        클래스		<ㅡ>		테이블
		     Object-graph      <ㅡ>		Relation
	   로 표현이 가능한데 표현방식에서 상당한 차이점이 있어 매핑을 통해 변환을 		   해주어야 한다.
	장점 ㅡ> 
		● 개발자가 OOP나 CBD에 의한 개발에만 집중가능
		● RDBMS관련 부분의 고려사항 최소화
	 	● OOP언어/CBD개발 방법론에서 클래스나 컴포넌트 설계 및 개발에서 
		    이질적인 RDBMS 관련된 부분을 최소화하고, 원 제품의 로직 구현에 
 		    충실하고자 하는 의도에서 나온 산물
		● 생산성이 높아지고 캐시 등 다양한 저장소를 활용하기에 유연한 구조			    를 만들어 준다.
		● 탑다운(Top-down)방식의 설계를 채택할 수 있는 경우 장점이 극대화 		    된다.
	단점 ㅡ>
		● 현실적으로 자바계층에 맞춰 DB스키마를 설계할 수 없는 프로젝트가 			    상당히 많으며 이런 경우 ORM을 염두에 두지 않고 설계된 리거시 스			    키마를 그대로 두고 바텀업(bottom-up)방식으로 구현하는 접근을 할 			    수 밖에 없기에 ORM의 장점이 상당히 퇴색
	 	● ORM기술 자체도 최적화나 복잡도, 또는 추상화 등의 이유로 꾸준히 			    비판받아왔다. 
	 	● 현재는 ORM을 사용하지 않고도 영속성 문제를 깔끔하게 처리할 수 			    있는 대안도 존재한다.
Maria DB
	- mysql 코어를 가지고 분리개발 한 것이 mariaDB
	   Mysql의 모든 명령어, 인터페이스, 라이브러리와 같은 API가 MariaDB에도 존	  	   재하며 MariaDB는 사실상 MySQL의 완벽한 대체제라고 말할 수 있다.
	   기능상의 차이는 거의 없지만 MariaDB의 퍼포먼스가 더 좋고 엔진도 추가되		   어 MySQL보다 뛰어나다.
	
	장점 ㅡ> 가장 큰 장점은 속도, 2배가량 퍼포먼스가 개선되었다.
MVC (Model View Controller)
	- 디자인 패턴 중 하나 ㅡ> 하나의 애플리케이션(프로젝트)를 세 가지의 역할로 						구분한 패턴
	 Model ㅡ> 애플리케이션의 정보 즉 데이터를 담당하며 데이터의 가공을 책임지			       는 컴포넌트
	 View ㅡ> 데이터 및 객체의 입력, 그리고 보여주는 출력을 담당하는 사용자 인			    터페이스 요소,
		    클라이언트 측 기술인 HTML/CSS/JavaScript 를 모아둔 컨테이너
	 Controller ㅡ> Model과 View의 다리역할을 하는, 비즈니스 로직을 담당하는 				  Controller
	● 왜 사용할까? 
	ㅡ> Model, View, Controller 서로 영향을 받지 않는 3가지로 분리하여 
	      각자의 역할에 집중할 수 있게끔 개발가능
	      애플리케이션의 확장성, 유지보수성, 유연성이 증가하고 중복코딩을 줄일 		      수 있다.
	유연성 ㅡ> 새로운 요구사항에 대해 최소한의 비용으로 보다 유연하게 대처할 			      수 있는 것
	     단점 - View가 Model을 이용하기에, 서로간의 의존성을 완벽히 피할 수 없			     다는 단점이 있다
		     ㅡ> 좋은 MVC는 의존성을 최대한 낮게 디자인한 패턴
	** NodeJS용 MVC 프레임워크로 Express(모듈) 가 있다.
AngularJS
	- 2013년 9월 1.0.8버전으로 정식 출시
	- AngularJS는 HTML을 확장시켜 동적인 Application을 지원하며 
	   데이터가 변경함에 있어 자동적으로 AngularJS에서 UI의 요소를 만들고 
	   데이터 필터링/소팅 등 많은 기능을 제공
	- AngularJS의 가장 핵심기능은 양방향 데이터바인딩 기능
	
	장점 
	- JavaScript나 jQuery에 비해 개발자의 부담이 훨씬 줄어든다.
	- 프레임워크 코어에 DOM변환 엔진을 넣어둠으로써 템플릿을 HTML파일로 작	 	   성가능
	   DOM변환 엔진을 통해 개발자는 AngularJS의 다양한 디렉티브(지시자)를 이	   	   용하여 HTML문법을 확장가능
	● Scope / Model / View / Controller / Directives(지시자)
	** Scope ㅡ> 모델 변경을 감지하고 표현하기 위한 책임을 갖는다. 
			(scope를 통해 View와 Controller간의 소통이 가능)
	** Model ㅡ> 화면 템플릿에 합쳐지는 데이터를 가지고 있는 자바스크립트 객체				(= 데이터)
		    	Scope는 항상 모델을 참조하고 있다.
	** View  ㅡ> Angular는 템플릿이 HTML이어서 바로 DOM으로 해석되고 
			DOM안에 directive가 템플릿 엔진 $compile지시어를 통해 				$watch를 설정하고 
			모델의 변경을 계속 감시하게 된다.
		          View는 템플릿으로 Scope의 투영체이고, Scope는 Model과 				View를 연결하며 Controller로 이벤트를 보내는 역할을 한다.  
	** Controller ㅡ> scope에 model과 function을 정의해주는 역할 
				ㅡ> 그러면 View가 그것들을 사용
			   자바스크립트이며 업무적 행위를 정의한다. 
			   또한 DOM 렌더링 정보가 일체 없다.
	** Directives(지시어) ㅡ> HTML을 확장하여 주고 행위를 일으키는 주체 
				  Ex) 데이터 바인딩을 위한 중괄호 표기 {{}}
				      컨트롤러가 뷰의 어느 부분을 감독할지 정하는 
				      ng-controller,
				      input을 해당 모델의 구성물에 바인딩하는 ng-model
				      이들 모두 directive를 이용한 확장 문법이다.

ER Diagram
Bootstrap
RESTful API
JSON
Responsive Web
Git
	Repository(저장소) ㅡ> 파일이나 폴더를 저장해 두는 곳
				    Git저장소의 장점은 파일이 변경이력별로 구분되어 저					    장된다.
	커밋 ㅡ> 파일 및 폴더의 추가 및 변경 사항을 저장소에 기록하기 위함
	커밋메세지형식 ㅡ> 명료하고 이해하기 쉽게 남기기
			1번째 줄 : 커밋 내의 변경 내용을 요약
			2번째 줄 : 빈칸
			3번째 줄 : 변경한 이유
	브랜치 ㅡ> 여러 개발자들이 동시에 다양한 작업을 할 수 있게 만들어 주는 기능
		      독립적으로 어떠한 작업을 진행하기 위한 개념
	통합 브랜치 ㅡ> 언제든지 배포할 수 있는 버전을 만들 수 있어야 하는 브랜치
			    항상 안정적인 상태를 유지해야 하는 브랜치
			    (보통 master로 사용)
	토픽 브랜치 ㅡ> 버그 수정이나 기능추가 등의 단위작업을 위한 브랜치
	HEAD ㅡ> 현재 사용중인 브랜치의 선두 부분을 나타내는 이름
		    'HEAD'를 이동하면, 사용하는 브랜치가 변경된다.
	stash ㅡ> 파일의 변경 내용을 일시적으로 기록해두는 영역
		     ex) 체크아웃 시 커밋하지 않은 변경내용 중 전환된 브랜치에서 이미 				 변경된 기록이 있을 경우 충돌이 일어날 수 있는데, 이 경우 				 stash로 변경 내용을 다른 곳에 저장 ㅡ> 충돌을 피한 후 체크아				 웃을 하면 된다.
	● merge와 rebase의 차이점
		merge					rebase
	변경내용의 이력이 모두 남아있기 / 이력은 단순해지지만, 원래의 커밋 이력이 							변경됨.
	때문에 이력이 복잡해짐	       / 정확한 이력을 남겨야 할 필요가 있을 경우							에는 사용하면 안됨.
	* rebase : 토픽 브랜치에 통합 브랜치의 최신 코드를 적용할 경우에 사용
	* merge : 통합 브랜치에 토픽 브랜치를 불러올 경우에는 우선 rebase를 한 후 			    merge
	● develop 브랜치 ㅡ> 통합 브랜치의 역할을 하며, 평소에는 이 브랜치를 기반					   으로 개발진행
Bitbucket
